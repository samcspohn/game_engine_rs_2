#version 450

struct Renderer {
    uint t_idx; // index into model_matrices
    uint m_id; // index into model -> indirect command(s) offset + count
    // material_id : uint;
};

struct RendererInit {
    uint idx;
    Renderer r;
    uint padding;
};

struct VkDrawIndexedIndirectCommand {
    int indexCount;
    uint instanceCount;
    uint firstIndex;
    int vertexOffset;
    uint firstInstance;
};

struct ModelIndirect {
    uint offset;
    uint count;
};
layout(set = 0, binding = 0) buffer ModelMatrices {
    mat4 model_matrices[];
};
layout(set = 0, binding = 1) buffer MVP {
    mat4 mvp[];
};
layout(set = 0, binding = 2) buffer Renderers {
    Renderer renderers[];
};

layout(set = 0, binding = 3) buffer RendererInits {
    RendererInit inits[];
};
layout(set = 0, binding = 4) buffer RendererUninits {
    uint uninits[];
};
layout(set = 0, binding = 5) buffer ModelIndirects {
    ModelIndirect model_indirect[]; // offset, count
};
layout(set = 0, binding = 6, std430) restrict buffer WorkgroupSumsBuffer {
    uint workgroupSums[];
};
layout(set = 0, binding = 7) buffer IndirectCommands {
    VkDrawIndexedIndirectCommand indirect[];
};

layout(set = 1, binding = 1) uniform camera {
    mat4 view;
    mat4 proj;
}
cam;

layout(set = 2, binding = 0) uniform Stage {
    uint num_jobs;
    uint stage;
    uint pass;
};

void pass0_localScan();
void pass1_globalScan();
void pass2_addGlobal();

// case 0: apply updates
// case 1: reset instance counts
// case 2: count renderers
// case 3: prefix sum first instance
// case 4: write indirect commands

layout(local_size_x = 64) in;
void main() {
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= num_jobs) {
        return;
    }
    switch (stage) {
        case 0:
        {
            switch (pass) {
                case 0:
                {
                    RendererInit u = inits[idx];
                    renderers[u.idx] = u.r;
                }
                break;
                case 1:
                {
                    uint u = uninits[idx];
                    renderers[u] = Renderer(-1, -1);
                }
                break;
            }
        }
        break;
        case 1:
        {
            indirect[idx].instanceCount = 0;
            indirect[idx].firstInstance = 0;
        }
        break;
        case 2:
        {
            Renderer r = renderers[idx];
            // Skip invalid/uninitialized renderers
            if (r.m_id == uint(-1) || r.t_idx == uint(-1)) {
                break;
            }
            ModelIndirect mc = model_indirect[r.m_id];
            for (uint i = 0; i < mc.count; ++i) {
                // atomicAdd(indirect[mc.offset + i].instanceCount, 1); // no culling yet
                atomicAdd(indirect[mc.offset + i].firstInstance, 1);
            }
            // atomicAdd(indirect[r.m_id].firstInstance, 1);
        }
        break;
        case 3:
        {
            switch (pass) {
                case 0:
                {
                    // local scan within workgroup
                    // see below for implementation
                    pass0_localScan();
                }
                break;
                case 1:
                {
                    // global scan of workgroup sums
                    pass1_globalScan();
                }
                break;
                case 2:
                {
                    // add global offsets to local results
                    pass2_addGlobal();
                }
                break;
            }
        }
        break;
        case 4:
        {
            switch (pass) {
                case 0:
                {
                    // reset instance counts to 0 for indirect draw
                    indirect[idx].instanceCount = 0;
                }
                break;
                case 1:
                {
                    // write indirect commands
                    Renderer r = renderers[idx];
                    // Skip invalid/uninitialized renderers
                    if (r.m_id == uint(-1) || r.t_idx == uint(-1)) {
                        break;
                    }
                    mat4 model_matrix = model_matrices[r.t_idx];
                    ModelIndirect mc = model_indirect[r.m_id];
                    for (uint i = 0; i < mc.count; ++i) {
                        uint mvp_idx = indirect[mc.offset + i].firstInstance +
                                atomicAdd(indirect[mc.offset + i].instanceCount, 1);
                        mvp[mvp_idx] = cam.proj * cam.view * model_matrix;
                    }
                }
                break;
            }
        }
        break;
    }
}

// Shared memory for local operations within workgroup
shared uint sharedData[gl_WorkGroupSize.x];
shared uint workgroupSum;

// =============================================================================
// UTILITY FUNCTIONS
// =============================================================================

// Up-sweep phase of scan (reduce phase)
void upSweep() {
    uint tid = gl_LocalInvocationID.x;
    uint stride = 1;

    // Build sum tree
    for (uint d = gl_WorkGroupSize.x >> 1; d > 0; d >>= 1) {
        barrier();
        if (tid < d) {
            uint ai = stride * (2 * tid + 1) - 1;
            uint bi = stride * (2 * tid + 2) - 1;
            sharedData[bi] += sharedData[ai];
        }
        stride <<= 1;
    }
}

// Down-sweep phase of scan
void downSweep() {
    uint tid = gl_LocalInvocationID.x;
    uint stride = gl_WorkGroupSize.x;

    // Clear root and store workgroup sum
    if (tid == 0) {
        workgroupSum = sharedData[gl_WorkGroupSize.x - 1];
        sharedData[gl_WorkGroupSize.x - 1] = 0;
    }

    // Traverse down tree building scan
    for (uint d = 1; d < gl_WorkGroupSize.x; d <<= 1) {
        stride >>= 1;
        barrier();
        if (tid < d) {
            uint ai = stride * (2 * tid + 1) - 1;
            uint bi = stride * (2 * tid + 2) - 1;

            uint temp = sharedData[ai];
            sharedData[ai] = sharedData[bi];
            sharedData[bi] += temp;
        }
    }
}

// Perform local prefix sum within workgroup
void localScan() {
    upSweep();
    downSweep();
}

// =============================================================================
// MAIN ALGORITHM PASSES
// =============================================================================

// Pass 0: Local scan within each workgroup
void pass0_localScan() {
    uint globalId = gl_GlobalInvocationID.x;
    uint localId = gl_LocalInvocationID.x;
    uint workgroupId = gl_WorkGroupID.x;

    // Load firstInstance data into shared memory
    if (globalId < uint(num_jobs)) {
        sharedData[localId] = indirect[globalId].firstInstance;
    } else {
        sharedData[localId] = 0; // Padding for out-of-bounds elements
    }

    barrier();

    // Perform local scan
    localScan();

    barrier();

    // Write results back to firstInstance field
    if (globalId < uint(num_jobs)) {
        indirect[globalId].firstInstance = sharedData[localId];
    }

    // Store workgroup sum for next pass
    if (localId == 0 && workgroupId < workgroupSums.length()) {
        workgroupSums[workgroupId] = workgroupSum;
    }
}

// Pass 1: Global scan of workgroup sums
void pass1_globalScan() {
    uint localId = gl_LocalInvocationID.x;
    uint workgroupId = gl_WorkGroupID.x;
    // uint globalId = workgroupId * gl_WorkGroupSize.x + localId;

    // Calculate number of workgroups from previous pass
    // uint workgroupCount = (uint(num_jobs) + gl_WorkGroupSize.x - 1) /
    // gl_WorkGroupSize.x;

    uint localSum = 0;
    float localSumSize =
        float(workgroupSums.length()) / float(gl_WorkGroupSize.x);
    // uint sum = 0;
    uint startIndex = uint(localSumSize * float(localId));
    uint endIndex = uint(localSumSize * float(localId + 1));

    // Only process if this thread has a valid range
    if (startIndex < endIndex && startIndex < workgroupSums.length()) {
        localSum = workgroupSums[startIndex];
        workgroupSums[startIndex] = 0; // Clear the first element for the scan

        for (uint i = startIndex + 1; i < endIndex && i < workgroupSums.length();
            ++i) {
            uint temp = workgroupSums[i];
            workgroupSums[i] = localSum;
            localSum += temp;
        }
    }

    // Load workgroup sums
    // if (localId < workgroupCount && localId < workgroupSums.length()) {
    sharedData[localId] = localSum;
    // } else {
    //     sharedData[localId] = 0;
    // }

    barrier();

    // Perform scan on workgroup sums
    localScan();

    barrier();

    // // Write scanned sums back
    // if (localId < workgroupCount && localId < workgroupSums.length()) {
    //     workgroupSums[localId] += sharedData[localId];
    // }
    // if (startIndex < endIndex) {
    for (uint i = startIndex; i < endIndex && i < workgroupSums.length(); ++i) {
        workgroupSums[i] += sharedData[localId];
    }
    // }
}

// Pass 2: Add global offsets to local results
void pass2_addGlobal() {
    uint globalId = gl_GlobalInvocationID.x;
    uint workgroupId = gl_WorkGroupID.x;

    if (globalId < uint(num_jobs) && workgroupId < workgroupSums.length()) {
        // Add the accumulated sum from previous workgroups
        indirect[globalId].firstInstance += workgroupSums[workgroupId];
    }
}
