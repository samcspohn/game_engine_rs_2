#version 450

// Hi-Z Generator using shared memory reduction
// Processes multiple mip levels in a single dispatch for efficiency
// Each workgroup generates up to 4 mip levels from a 16x16 tile

layout(local_size_x = 16, local_size_y = 16) in;

// Input: depth buffer (sampled texture)
layout(set = 0, binding = 0) uniform sampler2D srcDepth;

// Output: multiple mip levels as storage images
layout(set = 0, binding = 1, r32f) writeonly uniform image2D dstMip0;
layout(set = 0, binding = 2, r32f) writeonly uniform image2D dstMip1;
layout(set = 0, binding = 3, r32f) writeonly uniform image2D dstMip2;
layout(set = 0, binding = 4, r32f) writeonly uniform image2D dstMip3;

layout(push_constant) uniform PushConstants {
    uvec2 srcResolution; // Resolution of source depth buffer
    uint numMips; // Number of mips to generate (1-4)
} pc;

// Shared memory for reduction
// 16x16 for mip 0, used progressively smaller for higher mips
shared float sharedDepth[16][16];

void main() {
    uvec2 globalCoord = gl_GlobalInvocationID.xy;
    uvec2 localCoord = gl_LocalInvocationID.xy;

    // Load depth from source into shared memory
    float depth = 1.0; // Far plane default
    if (globalCoord.x < pc.srcResolution.x && globalCoord.y < pc.srcResolution.y) {
        depth = texelFetch(srcDepth, ivec2(globalCoord), 0).r;
    }
    sharedDepth[localCoord.y][localCoord.x] = depth;

    barrier();

    // === MIP LEVEL 0 ===
    // Write directly from shared memory
    if (pc.numMips >= 1) {
        if (globalCoord.x < pc.srcResolution.x && globalCoord.y < pc.srcResolution.y) {
            imageStore(dstMip0, ivec2(globalCoord), vec4(depth));
        }
    }

    barrier();

    // === MIP LEVEL 1 ===
    // Reduce 2x2 -> 1 using MIN
    if (pc.numMips >= 2) {
        if (localCoord.x % 2 == 0 && localCoord.y % 2 == 0) {
            // Sample 2x2 region from shared memory
            float d00 = sharedDepth[localCoord.y][localCoord.x];
            float d10 = sharedDepth[localCoord.y][localCoord.x + 1];
            float d01 = sharedDepth[localCoord.y + 1][localCoord.x];
            float d11 = sharedDepth[localCoord.y + 1][localCoord.x + 1];

            // Take minimum (furthest depth for conservative occlusion)
            float minDepth = min(min(d00, d10), min(d01, d11));

            // Store back to shared memory for next level
            sharedDepth[localCoord.y][localCoord.x] = minDepth;

            // Write to mip 1
            uvec2 mip1Coord = globalCoord / 2;
            uvec2 mip1Size = (pc.srcResolution + 1) / 2;
            if (mip1Coord.x < mip1Size.x && mip1Coord.y < mip1Size.y) {
                imageStore(dstMip1, ivec2(mip1Coord), vec4(minDepth));
            }
        }
    }

    barrier();

    // === MIP LEVEL 2 ===
    // Reduce 4x4 -> 1 (or 2x2 from mip1)
    if (pc.numMips >= 3) {
        if (localCoord.x % 4 == 0 && localCoord.y % 4 == 0) {
            // Sample 2x2 region from mip 1 data in shared memory
            float d00 = sharedDepth[localCoord.y][localCoord.x];
            float d10 = sharedDepth[localCoord.y][localCoord.x + 2];
            float d01 = sharedDepth[localCoord.y + 2][localCoord.x];
            float d11 = sharedDepth[localCoord.y + 2][localCoord.x + 2];

            float minDepth = min(min(d00, d10), min(d01, d11));

            // Store back to shared memory
            sharedDepth[localCoord.y][localCoord.x] = minDepth;

            // Write to mip 2
            uvec2 mip2Coord = globalCoord / 4;
            uvec2 mip2Size = (pc.srcResolution + 3) / 4;
            if (mip2Coord.x < mip2Size.x && mip2Coord.y < mip2Size.y) {
                imageStore(dstMip2, ivec2(mip2Coord), vec4(minDepth));
            }
        }
    }

    barrier();

    // === MIP LEVEL 3 ===
    // Reduce 8x8 -> 1 (or 2x2 from mip2)
    if (pc.numMips >= 4) {
        if (localCoord.x % 8 == 0 && localCoord.y % 8 == 0) {
            // Sample 2x2 region from mip 2 data in shared memory
            float d00 = sharedDepth[localCoord.y][localCoord.x];
            float d10 = sharedDepth[localCoord.y][localCoord.x + 4];
            float d01 = sharedDepth[localCoord.y + 4][localCoord.x];
            float d11 = sharedDepth[localCoord.y + 4][localCoord.x + 4];

            float minDepth = min(min(d00, d10), min(d01, d11));

            // Write to mip 3
            uvec2 mip3Coord = globalCoord / 8;
            uvec2 mip3Size = (pc.srcResolution + 7) / 8;
            if (mip3Coord.x < mip3Size.x && mip3Coord.y < mip3Size.y) {
                imageStore(dstMip3, ivec2(mip3Coord), vec4(minDepth));
            }
        }
    }
}
