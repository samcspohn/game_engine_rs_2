#version 450

struct Renderer {
    uint t_idx; // index into model_matrices
    uint m_id; // index into model -> indirect command(s) offset + count
    // material_id : uint;
};

struct RendererInit {
    uint idx;
    Renderer r;
    uint padding;
};

struct VkDrawIndexedIndirectCommand {
    int indexCount;
    uint instanceCount;
    uint firstIndex;
    int vertexOffset;
    uint firstInstance;
};

struct ModelIndirect {
    uint offset;
    uint count;
};

struct MatrixData {
    mat4 model;
    mat3 normal;
    mat4 mvp;
};

struct AABB {
    vec4 min;
    vec4 max;
};

// layout(set = 1, binding = 5) buffer DirtyL2 { uint dirty_l2[]; };
layout(set = 0, binding = 0) buffer MatrixBuffer {
    MatrixData m[];
};

struct RenderData {
    uint t_id;
    uint mat_id;
};

layout(set = 0, binding = 1) buffer TransformIDs {
    RenderData transform_ids[];
};

layout(set = 0, binding = 2) buffer Renderers {
    Renderer renderers[];
};

layout(set = 0, binding = 3) buffer RendererInits {
    RendererInit inits[];
};
layout(set = 0, binding = 4) buffer RendererUninits {
    uint uninits[];
};
layout(set = 0, binding = 5) buffer ModelIndirects {
    ModelIndirect model_indirect[]; // offset, count
};
layout(set = 0, binding = 6, std430) restrict buffer WorkgroupSumsBuffer {
    uint workgroupSums[];
};
layout(set = 0, binding = 7) buffer IndirectCommands {
    VkDrawIndexedIndirectCommand indirect[];
};
layout(set = 0, binding = 8) buffer MaterialIds {
    uint material_ids[];
};
layout(set = 0, binding = 9) buffer AABBs {
    AABB aabbs[];
};

// Hi-Z buffer for occlusion culling (optional - may be dummy texture if not initialized)
layout(set = 1, binding = 0) uniform sampler2D hizBuffer;

// Camera uniform for occlusion culling (can be frozen for debugging)
layout(set = 1, binding = 1) uniform cameraCulling {
    mat4 view;
    mat4 proj;
}
camCulling;

// Camera uniform for rendering (always uses current camera state)
layout(set = 1, binding = 3) uniform cameraRendering {
    mat4 view;
    mat4 proj;
}
camRender;

layout(set = 1, binding = 2) uniform HiZInfo {
    ivec2 screenResolution;
    // uint mipLevels;
    // float padding;
} hizInfo;

layout(set = 2, binding = 0) uniform Stage {
    uint num_jobs;
    uint stage;
    uint pass;
};

void pass0_localScan();
void pass1_globalScan();
void pass2_addGlobal();

// Check if Hi-Z is available and valid
bool isHiZAvailable() {
    // Check if screen resolution is valid
    if (hizInfo.screenResolution.x <= 0 || hizInfo.screenResolution.y <= 0) {
        return false;
    }
    // Check if Hi-Z has mip levels
    if (textureQueryLevels(hizBuffer) <= 0) {
        return false;
    }
    return true;
}

// Occlusion test function
bool isOccluded(uint meshId, uint transformId) {
    // Safety check: if Hi-Z not available, don't cull anything
    if (!isHiZAvailable()) {
        return false;
    }

    // Bounds check for AABB array
    if (meshId >= aabbs.length()) {
        return false; // Don't cull if we don't have AABB data
    }
    AABB bbox = aabbs[meshId];
    vec3 center = (bbox.min.xyz + bbox.max.xyz) * 0.5;
    vec3 extents = (bbox.max.xyz - bbox.min.xyz) * 0.5;
    bbox.max.xyz = center + extents * 1.05; // Slightly expand to avoid precision issues
    bbox.min.xyz = center - extents * 1.05;

    mat4 mvp = camCulling.proj * camCulling.view * m[transformId].model;

    // 1. Generate and transform 8 corners
    vec3 corners[8];
    corners[0] = vec3(bbox.min.x, bbox.min.y, bbox.min.z);
    corners[1] = vec3(bbox.max.x, bbox.min.y, bbox.min.z);
    corners[2] = vec3(bbox.min.x, bbox.max.y, bbox.min.z);
    corners[3] = vec3(bbox.max.x, bbox.max.y, bbox.min.z);
    corners[4] = vec3(bbox.min.x, bbox.min.y, bbox.max.z);
    corners[5] = vec3(bbox.max.x, bbox.min.y, bbox.max.z);
    corners[6] = vec3(bbox.min.x, bbox.max.y, bbox.max.z);
    corners[7] = vec3(bbox.max.x, bbox.max.y, bbox.max.z);

    // 2. Project to screen space and find bounds
    vec2 screenMin = vec2(1e10);
    vec2 screenMax = vec2(-1e10);
    float minDepth = 1.0;
    bool anyInFront = false;
    bool anyBehind = false;

    for (int i = 0; i < 8; ++i) {
        vec4 clipPos = mvp * vec4(corners[i], 1.0);

        if (clipPos.w > 0.0) {
            anyInFront = true;
            vec3 ndc = clipPos.xyz / clipPos.w;
            // Vulkan uses inverted Y viewport (Y increases downward)
            vec2 screenPos = vec2(ndc.x * 0.5 + 0.5, 1.0 - (ndc.y * 0.5 + 0.5));

            screenMin = min(screenMin, screenPos);
            screenMax = max(screenMax, screenPos);
            minDepth = min(minDepth, ndc.z);
        } else {
            anyBehind = true;
        }
    }

    // Camera is inside or intersecting the AABB - don't cull
    if (anyInFront && anyBehind) {
        return false;
    }

    // All corners behind camera
    if (!anyInFront) {
        return true; // Cull it
    }

    // Clamp to screen
    screenMin = clamp(screenMin, vec2(0.0), vec2(1.0));
    screenMax = clamp(screenMax, vec2(0.0), vec2(1.0));

    // 3. Select mip level
    vec2 screenSize = (screenMax - screenMin) * vec2(hizInfo.screenResolution);
    float maxDim = max(screenSize.x, screenSize.y);

    // Handle edge case where object is very small or offscreen
    if (maxDim < 1.0) {
        maxDim = 1.0;
    }

    // If object covers no pixels, it's effectively culled
    if (maxDim <= 0.0) {
        return true;
    }

    int numMips = textureQueryLevels(hizBuffer);
    int mipLevel = int(clamp(ceil(log2(maxDim)), 0.0, float(numMips - 1)));

    float d0 = textureLod(hizBuffer, screenMin, mipLevel).r;
    float d1 = textureLod(hizBuffer, vec2(screenMax.x, screenMin.y), mipLevel).r;
    float d2 = textureLod(hizBuffer, vec2(screenMin.x, screenMax.y), mipLevel).r;
    float d3 = textureLod(hizBuffer, screenMax, mipLevel).r;
    float occluderDepth = max(max(d0, d1), max(d2, d3));

    // float bias = max(0.00001, occluderDepth * 0.0001); // 0.01% of depth value
    // float bias = 1.0 + 0.00001; // Fixed small bias
    bool visible = minDepth <= occluderDepth;
    return !visible;
}

// case 0: apply updates
// case 1: reset instance counts
// case 2: count renderers
// case 3: prefix sum first instance
// case 4: write indirect commands

float closeness(uint
    meshId, uint
    transformId) {
    mat4 modelMatrix = m[transformId].model;
    AABB bbox = aabbs[meshId];
    // vec4 center = (bbox.min + bbox.max) * 0.5;
    vec4 center = vec4((bbox.min.xyz + bbox.max.xyz) * 0.5, 1.0);
    vec4 worldPos = modelMatrix * center;
    vec4 viewPos = camCulling.view * worldPos;
    return length(viewPos.xyz);
    // vec4 worldPos = modelMatrix * vec4(0.0, 0.0, 0.0, 1.0);
    // vec4 viewPos = cam.view * worldPos;
    // return length(viewPos.xyz);
}

layout(local_size_x = 64) in;
void main() {
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= num_jobs) {
        return;
    }
    switch (stage) {
        case 0:
        {
            switch (pass) {
                case 0:
                {
                    RendererInit u = inits[idx];
                    renderers[u.idx] = u.r;
                }
                break;
                case 1:
                {
                    uint u = uninits[idx];
                    renderers[u] = Renderer(-1, -1);
                }
                break;
            }
        }
        break;
        case 1:
        {
            indirect[idx].instanceCount = 0;
            indirect[idx].firstInstance = 0;
        }
        break;
        case 2:
        {
            // count all instances for each renderer to make space for all cameras
            Renderer r = renderers[idx];
            // Skip invalid/uninitialized renderers
            if (r.m_id == uint(-1) || r.t_idx == uint(-1)) {
                break;
            }
            ModelIndirect mc = model_indirect[r.m_id];
            if (mc.offset == uint(-1)) {
                break;
            }
            for (uint i = 0; i < mc.count; ++i) {
                atomicAdd(indirect[mc.offset + i].firstInstance, 1);
            }
            // atomicAdd(indirect[r.m_id].firstInstance, 1);
        }
        break;
        case 3:
        {
            switch (pass) {
                case 0:
                {
                    // local scan within workgroup
                    // see below for implementation
                    pass0_localScan();
                }
                break;
                case 1:
                {
                    // global scan of workgroup sums
                    pass1_globalScan();
                }
                break;
                case 2:
                {
                    // add global offsets to local results
                    pass2_addGlobal();
                }
                break;
            }
        }
        break;
        case 4:
        {
            switch (pass) {
                case 0:
                {
                    // reset instance counts to 0 for indirect draw
                    indirect[idx].instanceCount = 0;
                }
                break;
                case 1:
                {
                    // write indirect commands
                    Renderer r = renderers[idx];
                    // Skip invalid/uninitialized renderers
                    if (r.m_id == uint(-1) || r.t_idx == uint(-1)) {
                        break;
                    }
                    ModelIndirect mc = model_indirect[r.m_id];
                    if (mc.offset == uint(-1)) {
                        break;
                    }
                    mat4 model_matrix = m[r.t_idx].model;
                    m[r.t_idx].mvp = camRender.proj * camRender.view * model_matrix;
                    // mat3 normal = inverse(transpose(mat3(model_matrix)));
                    for (uint i = 0; i < mc.count; ++i) {
                        // Occlusion test: only count visible meshes
                        if (isOccluded(mc.offset + i, r.t_idx)) {
                            continue;
                        }
                        // if (closeness(mc.offset + i, r.t_idx) > 10.0) {
                        //     continue;
                        // }
                        uint mvp_idx = indirect[mc.offset + i].firstInstance +
                                atomicAdd(indirect[mc.offset + i].instanceCount, 1);
                        transform_ids[mvp_idx].t_id = r.t_idx;
                        transform_ids[mvp_idx].mat_id = material_ids[mc.offset + i];
                        // mvp[mvp_idx] = cam.proj * cam.view * model_matrix;
                        // normal_matrices[mvp_idx] = normal;
                    }
                }
                break;
            }
        }
        break;
    }
}

// Shared memory for local operations within workgroup
shared uint sharedData[gl_WorkGroupSize.x];
shared uint workgroupSum;

// =============================================================================
// UTILITY FUNCTIONS
// =============================================================================

// Up-sweep phase of scan (reduce phase)
void upSweep() {
    uint tid = gl_LocalInvocationID.x;
    uint stride = 1;

    // Build sum tree
    for (uint d = gl_WorkGroupSize.x >> 1; d > 0; d >>= 1) {
        barrier();
        if (tid < d) {
            uint ai = stride * (2 * tid + 1) - 1;
            uint bi = stride * (2 * tid + 2) - 1;
            sharedData[bi] += sharedData[ai];
        }
        stride <<= 1;
    }
}

// Down-sweep phase of scan
void downSweep() {
    uint tid = gl_LocalInvocationID.x;
    uint stride = gl_WorkGroupSize.x;

    // Clear root and store workgroup sum
    if (tid == 0) {
        workgroupSum = sharedData[gl_WorkGroupSize.x - 1];
        sharedData[gl_WorkGroupSize.x - 1] = 0;
    }

    // Traverse down tree building scan
    for (uint d = 1; d < gl_WorkGroupSize.x; d <<= 1) {
        stride >>= 1;
        barrier();
        if (tid < d) {
            uint ai = stride * (2 * tid + 1) - 1;
            uint bi = stride * (2 * tid + 2) - 1;

            uint temp = sharedData[ai];
            sharedData[ai] = sharedData[bi];
            sharedData[bi] += temp;
        }
    }
}

// Perform local prefix sum within workgroup
void localScan() {
    upSweep();
    downSweep();
}

// =============================================================================
// MAIN ALGORITHM PASSES
// =============================================================================

// Pass 0: Local scan within each workgroup
void pass0_localScan() {
    uint globalId = gl_GlobalInvocationID.x;
    uint localId = gl_LocalInvocationID.x;
    uint workgroupId = gl_WorkGroupID.x;

    // Load firstInstance data into shared memory
    if (globalId < uint(num_jobs)) {
        sharedData[localId] = indirect[globalId].firstInstance;
    } else {
        sharedData[localId] = 0; // Padding for out-of-bounds elements
    }

    barrier();

    // Perform local scan
    localScan();

    barrier();

    // Write results back to firstInstance field
    if (globalId < uint(num_jobs)) {
        indirect[globalId].firstInstance = sharedData[localId];
    }

    // Store workgroup sum for next pass
    if (localId == 0 && workgroupId < workgroupSums.length()) {
        workgroupSums[workgroupId] = workgroupSum;
    }
}

// Pass 1: Global scan of workgroup sums
void pass1_globalScan() {
    uint localId = gl_LocalInvocationID.x;
    uint workgroupId = gl_WorkGroupID.x;
    // uint globalId = workgroupId * gl_WorkGroupSize.x + localId;

    // Calculate number of workgroups from previous pass
    // uint workgroupCount = (uint(num_jobs) + gl_WorkGroupSize.x - 1) /
    // gl_WorkGroupSize.x;

    uint localSum = 0;
    float localSumSize =
        float(workgroupSums.length()) / float(gl_WorkGroupSize.x);
    // uint sum = 0;
    uint startIndex = uint(localSumSize * float(localId));
    uint endIndex = uint(localSumSize * float(localId + 1));

    // Only process if this thread has a valid range
    if (startIndex < endIndex && startIndex < workgroupSums.length()) {
        localSum = workgroupSums[startIndex];
        workgroupSums[startIndex] = 0; // Clear the first element for the scan

        for (uint i = startIndex + 1; i < endIndex && i < workgroupSums.length();
            ++i) {
            uint temp = workgroupSums[i];
            workgroupSums[i] = localSum;
            localSum += temp;
        }
    }

    // Load workgroup sums
    // if (localId < workgroupCount && localId < workgroupSums.length()) {
    sharedData[localId] = localSum;
    // } else {
    //     sharedData[localId] = 0;
    // }

    barrier();

    // Perform scan on workgroup sums
    localScan();

    barrier();

    // // Write scanned sums back
    // if (localId < workgroupCount && localId < workgroupSums.length()) {
    //     workgroupSums[localId] += sharedData[localId];
    // }
    // if (startIndex < endIndex) {
    for (uint i = startIndex; i < endIndex && i < workgroupSums.length(); ++i) {
        workgroupSums[i] += sharedData[localId];
    }
    // }
}

// Pass 2: Add global offsets to local results
void pass2_addGlobal() {
    uint globalId = gl_GlobalInvocationID.x;
    uint workgroupId = gl_WorkGroupID.x;

    if (globalId < uint(num_jobs) && workgroupId < workgroupSums.length()) {
        // Add the accumulated sum from previous workgroups
        indirect[globalId].firstInstance += workgroupSums[workgroupId];
    }
}
