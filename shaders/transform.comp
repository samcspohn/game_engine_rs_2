#version 460
#extension GL_EXT_nonuniform_qualifier : require
#include "transformation.glsl"

// static-ish buffers
layout(set = 0, binding = 0) buffer Positions {
    vec3 positions[];
};
layout(set = 0, binding = 1) buffer Rotations {
    vec4 rotations[];
};
layout(set = 0, binding = 2) buffer Scales {
    vec3 scales[];
};
layout(set = 0, binding = 3) buffer ParentIndices {
    uint parent_indices[];
};

layout(set = 1, binding = 0) buffer UPositions {
    float u_positions[];
};
layout(set = 1, binding = 1) buffer URotations {
    float u_rotations[];
};
layout(set = 1, binding = 2) buffer UScales {
    float u_scales[];
};
layout(set = 1, binding = 3) buffer UFlags {
    uint u_flags[];
};
layout(set = 1, binding = 4) buffer UParentIndices {
    uint u_parent_indices[];
};
// layout(set = 1, binding = 5) buffer DirtyL2 { uint dirty_l2[]; };
layout(set = 2, binding = 0) buffer ModelMatrices {
    mat4 model_matrices[];
};

layout(set = 3, binding = 0) uniform PushConstants {
    uint stage; // 0 = apply updates, 1 = compute matrices
    uint count;
    uint update;
}
pc;

mat4 compute_model_matrix(vec3 position, vec4 rotation, vec3 scale) {
    mat4 translation_matrix = mat4(1.0);
    translation_matrix[3] = vec4(position, 1.0);

    mat4 rotation_matrix = mat4(1.0);
    float x = rotation.x;
    float y = rotation.y;
    float z = rotation.z;
    float w = rotation.w;
    rotation_matrix[0][0] = 1.0 - 2.0 * (y * y + z * z);
    rotation_matrix[0][1] = 2.0 * (x * y - z * w);
    rotation_matrix[0][2] = 2.0 * (x * z + y * w);
    rotation_matrix[1][0] = 2.0 * (x * y + z * w);
    rotation_matrix[1][1] = 1.0 - 2.0 * (x * x + z * z);
    rotation_matrix[1][2] = 2.0 * (y * z - x * w);
    rotation_matrix[2][0] = 2.0 * (x * z - y * w);
    rotation_matrix[2][1] = 2.0 * (y * z + x * w);
    rotation_matrix[2][2] = 1.0 - 2.0 * (x * x + y * y);

    mat4 scale_matrix = mat4(1.0);
    scale_matrix[0][0] = scale.x;
    scale_matrix[1][1] = scale.y;
    scale_matrix[2][2] = scale.z;

    return translation_matrix * rotation_matrix * scale_matrix;
}

// struct Transform {
//     vec3 position;
//     vec4 rotation;
//     vec3 scale;
//     int parent_index;
// };

mat4 get_global_matrix(uint index) {
    if (index == -1) {
        return mat4(1.0);
    }

    vec3 position = positions[index];
    vec4 rotation = rotations[index];
    vec3 scale = scales[index];
    uint parent_index = parent_indices[index];
    mat4 global_matrix = compute_model_matrix(position, rotation, scale);
    uint sanity_counter = 0;
    while (parent_index != -1 && sanity_counter < 10) {
        position = positions[parent_index];
        rotation = rotations[parent_index];
        scale = scales[parent_index];
        global_matrix =
            compute_model_matrix(position, rotation, scale) * global_matrix;
        parent_index = parent_indices[parent_index];
        sanity_counter += 1;
    }
    return global_matrix;
    // return get_global_matrix(t.parent_index) * compute_model_matrix(t.position,
    // t.rotation, t.scale);
}

layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main() {
    uint idx = gl_GlobalInvocationID.x;
    switch (pc.stage) {
        case 0:
        {
            if (pc.update == 0) {
                return;
            }
            if (idx >= pc.count) {
                return;
            }
            uint pos_flag = idx / 32 * 3;
            uint rot_flag = idx / 32 * 3 + 1;
            uint scale_flag = idx / 32 * 3 + 2;
            uint i = idx % 32;
            if (((u_flags[pos_flag] >> i) & 1) != 0) {
                positions[idx] = vec3(u_positions[idx * 3], u_positions[idx * 3 + 1],
                        u_positions[idx * 3 + 2]);
            }
            if (((u_flags[rot_flag] >> i) & 1) != 0) {
                rotations[idx] =
                    vec4(u_rotations[idx * 4], u_rotations[idx * 4 + 1],
                        u_rotations[idx * 4 + 2], u_rotations[idx * 4 + 3]);
            }
            if (((u_flags[scale_flag] >> i) & 1) != 0) {
                scales[idx] = vec3(u_scales[idx * 3], u_scales[idx * 3 + 1],
                        u_scales[idx * 3 + 2]);
            }
        }
        break;
        case 1:
        {
            if (idx >= pc.count) {
                return;
            }
            idx = idx * 2;
            uint id = u_parent_indices[idx];
            uint parent_id = u_parent_indices[idx + 1];
            parent_indices[id] = parent_id;
        }
        break;
        case 2:
        {
            if (idx >= pc.count) {
                return;
            }
            // model_matrices[idx] =
            //     compute_model_matrix(positions[idx], rotations[idx], scales[idx]);
            model_matrices[idx] = translate(positions[idx]) * rotate(rotations[idx]) * scale(scales[idx]);
        }
        break;
        default:
        return;
    }
}
