#version 450

// Hi-Z Generator using shared memory reduction
// Generates mip levels 1-4 from source mip level 0
// Each workgroup processes a 32x32 region of the source to generate a 16x16 output for mip 1

layout(local_size_x = 16, local_size_y = 16) in;

// Input: source mip level (sampled texture)
layout(set = 0, binding = 0) uniform sampler2D srcMip;

// Output: multiple mip levels as storage images (these are mip N+1, N+2, N+3, N+4 relative to src)
layout(set = 0, binding = 1, r32f) writeonly uniform image2D dstMip0; // mip N+1
layout(set = 0, binding = 2, r32f) writeonly uniform image2D dstMip1; // mip N+2
layout(set = 0, binding = 3, r32f) writeonly uniform image2D dstMip2; // mip N+3
layout(set = 0, binding = 4, r32f) writeonly uniform image2D dstMip3; // mip N+4

layout(push_constant) uniform PushConstants {
    uvec2 srcResolution; // Resolution of source mip level
    uint numMips; // Number of mips to generate (1-4)
} pc;

// Shared memory for reduction - stores 16x16 region for progressive downsampling
shared float sharedDepth[16][16];

void main() {
    uvec2 localCoord = gl_LocalInvocationID.xy;
    uvec2 workGroupId = gl_WorkGroupID.xy;

    // === MIP LEVEL 0 (N+1) ===
    // Each thread samples a 2x2 region from source and takes MIN
    // This generates the first output mip level from the source texture

    uvec2 srcCoord = workGroupId * 32 + localCoord * 2;

    float maxDepth = 0.0; // Near plane (will be updated to furthest/MAX)

    // Sample 2x2 region from source texture
    if (srcCoord.x < pc.srcResolution.x && srcCoord.y < pc.srcResolution.y) {
        float d00 = texelFetch(srcMip, ivec2(srcCoord.x, srcCoord.y), 0).r;
        float d10 = texelFetch(srcMip, ivec2(min(srcCoord.x + 1, pc.srcResolution.x - 1), srcCoord.y), 0).r;
        float d01 = texelFetch(srcMip, ivec2(srcCoord.x, min(srcCoord.y + 1, pc.srcResolution.y - 1)), 0).r;
        float d11 = texelFetch(srcMip, ivec2(min(srcCoord.x + 1, pc.srcResolution.x - 1), min(srcCoord.y + 1, pc.srcResolution.y - 1)), 0).r;

        // Take MAX for conservative occlusion (MAX = furthest depth, since far plane = 1.0)
        maxDepth = max(max(d00, d10), max(d01, d11));
    } else {
        maxDepth = 1.0; // Far plane for out of bounds
    }

    // Store in shared memory for further reduction
    sharedDepth[localCoord.y][localCoord.x] = maxDepth;

    // Write first output mip (mip N+1)
    if (pc.numMips >= 1) {
        uvec2 dstCoord = workGroupId * 16 + localCoord;
        uvec2 dstSize = (pc.srcResolution + 1) / 2;
        if (dstCoord.x < dstSize.x && dstCoord.y < dstSize.y) {
            imageStore(dstMip0, ivec2(dstCoord), vec4(maxDepth));
        }
    }

    barrier();

    // === MIP LEVEL 1 (N+2) ===
    // Reduce 2x2 from shared memory -> 1
    if (pc.numMips >= 2) {
        if (localCoord.x % 2 == 0 && localCoord.y % 2 == 0) {
            float d00 = sharedDepth[localCoord.y][localCoord.x];
            float d10 = sharedDepth[localCoord.y][min(localCoord.x + 1, 15)];
            float d01 = sharedDepth[min(localCoord.y + 1, 15)][localCoord.x];
            float d11 = sharedDepth[min(localCoord.y + 1, 15)][min(localCoord.x + 1, 15)];

            maxDepth = max(max(d00, d10), max(d01, d11));
            sharedDepth[localCoord.y][localCoord.x] = maxDepth;

            uvec2 dstCoord = workGroupId * 8 + localCoord / 2;
            uvec2 dstSize = (pc.srcResolution + 3) / 4;
            if (dstCoord.x < dstSize.x && dstCoord.y < dstSize.y) {
                imageStore(dstMip1, ivec2(dstCoord), vec4(maxDepth));
            }
        }
    }

    barrier();

    // === MIP LEVEL 2 (N+3) ===
    // Reduce 4x4 from original -> 1 (2x2 from mip1)
    if (pc.numMips >= 3) {
        if (localCoord.x % 4 == 0 && localCoord.y % 4 == 0) {
            float d00 = sharedDepth[localCoord.y][localCoord.x];
            float d10 = sharedDepth[localCoord.y][min(localCoord.x + 2, 15)];
            float d01 = sharedDepth[min(localCoord.y + 2, 15)][localCoord.x];
            float d11 = sharedDepth[min(localCoord.y + 2, 15)][min(localCoord.x + 2, 15)];

            maxDepth = max(max(d00, d10), max(d01, d11));
            sharedDepth[localCoord.y][localCoord.x] = maxDepth;

            uvec2 dstCoord = workGroupId * 4 + localCoord / 4;
            uvec2 dstSize = (pc.srcResolution + 7) / 8;
            if (dstCoord.x < dstSize.x && dstCoord.y < dstSize.y) {
                imageStore(dstMip2, ivec2(dstCoord), vec4(maxDepth));
            }
        }
    }

    barrier();

    // === MIP LEVEL 3 (N+4) ===
    // Reduce 8x8 from original -> 1 (2x2 from mip2)
    if (pc.numMips >= 4) {
        if (localCoord.x % 8 == 0 && localCoord.y % 8 == 0) {
            float d00 = sharedDepth[localCoord.y][localCoord.x];
            float d10 = sharedDepth[localCoord.y][min(localCoord.x + 4, 15)];
            float d01 = sharedDepth[min(localCoord.y + 4, 15)][localCoord.x];
            float d11 = sharedDepth[min(localCoord.y + 4, 15)][min(localCoord.x + 4, 15)];

            maxDepth = max(max(d00, d10), max(d01, d11));

            uvec2 dstCoord = workGroupId * 2 + localCoord / 8;
            uvec2 dstSize = (pc.srcResolution + 15) / 16;
            if (dstCoord.x < dstSize.x && dstCoord.y < dstSize.y) {
                imageStore(dstMip3, ivec2(dstCoord), vec4(maxDepth));
            }
        }
    }
}
